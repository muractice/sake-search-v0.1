# 差分検出の仕組み（SHA256ハッシュ方式）

## 概要
SHA256ハッシュを使用して、日本酒データの変更を効率的に検出する仕組みの詳細解説。

## 1. SHA256ハッシュとは

### 基本概念
- **SHA256**: Secure Hash Algorithm 256-bit
- **特徴**: 任意長のデータから固定長（256ビット = 64文字）の文字列を生成
- **一方向性**: ハッシュ値から元データは復元不可能
- **衝突耐性**: 異なるデータから同じハッシュ値が生成される確率は極めて低い

### 例
```javascript
データ: "獺祭 純米大吟醸"
SHA256: "a7b9c3d2e4f5..."（64文字の16進数）

データ: "獺祭 純米大吟醸" （1文字でも変更）
SHA256: "f2e8a1b7c9d4..."（全く異なるハッシュ値）
```

## 2. 実装の詳細

### ハッシュ計算対象のデータ
```javascript
calculateHash(record) {
  // ハッシュ計算に使用するフィールドを選択
  const dataForHash = {
    brand_name: record.brand_name,        // 銘柄名
    brewery_name: record.brewery_name,    // 蔵元名
    sweetness: Math.round(record.sweetness * 1000) / 1000,  // 甘辛度（小数点3桁）
    richness: Math.round(record.richness * 1000) / 1000,    // 淡濃度（小数点3桁）
    f1: record.f1_floral,  // 華やか度
    f2: record.f2_mellow,  // 芳醇度
    f3: record.f3_heavy,   // 重厚度
    f4: record.f4_mild,    // 穏やか度
    f5: record.f5_dry,     // ドライ度
    f6: record.f6_light    // 軽快度
  };
  
  // JSONに変換（順序を保証）
  const dataString = JSON.stringify(dataForHash);
  
  // SHA256ハッシュを計算
  return crypto.createHash('sha256').update(dataString).digest('hex');
}
```

### なぜこれらのフィールドを選ぶのか
- **実データのみ**: IDや更新日時などのメタデータは除外
- **ビジネス的に重要**: 味わいデータは全て含む
- **変更検出対象**: ユーザーに影響する変更のみ検出

## 3. 差分検出フロー

### Step 1: 現在のデータを取得
```javascript
// DBから現在のデータとハッシュ値を取得
const currentData = await supabase
  .from('sake_master')
  .select('brand_id, brand_name, data_hash, ...')
  .eq('is_active', true);

// brand_idをキーとしたMapに変換
const currentMap = new Map(
  currentData.map(r => [r.brand_id, r])
);
```

### Step 2: APIデータのハッシュ計算
```javascript
const apiData = await fetchFromSakenowaAPI();

for (const apiRecord of apiData) {
  // 新しいデータのハッシュを計算
  const newHash = calculateHash(apiRecord);
  
  // 現在のデータと比較
  const currentRecord = currentMap.get(apiRecord.brand_id);
  
  if (!currentRecord) {
    // 新規データ
    changes.inserts.push(apiRecord);
  } else if (currentRecord.data_hash !== newHash) {
    // ハッシュが異なる = データが変更された
    changes.updates.push({
      old: currentRecord,
      new: apiRecord,
      changedFields: detectChangedFields(currentRecord, apiRecord)
    });
  }
  // ハッシュが同じ = 変更なし（何もしない）
}
```

### Step 3: 削除検出
```javascript
// APIに存在しないデータ = 削除された
for (const [brandId, record] of currentMap) {
  if (!apiDataIds.has(brandId)) {
    changes.deletes.push(record);
  }
}
```

## 4. 実例シミュレーション

### ケース1: データ変更なし
```javascript
// 現在のDB
{
  brand_id: 1,
  brand_name: "獺祭 純米大吟醸 50",
  sweetness: 1.5,
  richness: -2.0,
  data_hash: "a7b9c3d2e4f5g6h7i8j9k0l1m2n3o4p5"
}

// APIから取得
{
  brand_id: 1,
  brand_name: "獺祭 純米大吟醸 50",
  sweetness: 1.5,
  richness: -2.0
}

// ハッシュ計算
newHash = "a7b9c3d2e4f5g6h7i8j9k0l1m2n3o4p5"  // 同じ

// 結果: 変更なし → スキップ
```

### ケース2: 味わいデータ変更
```javascript
// 現在のDB
{
  brand_id: 1,
  brand_name: "獺祭 純米大吟醸 50",
  sweetness: 1.5,
  richness: -2.0,
  data_hash: "a7b9c3d2e4f5g6h7i8j9k0l1m2n3o4p5"
}

// APIから取得（richnessが変更）
{
  brand_id: 1,
  brand_name: "獺祭 純米大吟醸 50",
  sweetness: 1.5,
  richness: -1.8  // 変更！
}

// ハッシュ計算
newHash = "q9r8s7t6u5v4w3x2y1z0a9b8c7d6e5f4"  // 異なる

// 結果: 更新対象
// 変更フィールド: ["richness"]
```

### ケース3: 新規データ
```javascript
// 現在のDB
// brand_id: 999 は存在しない

// APIから取得
{
  brand_id: 999,
  brand_name: "新しい日本酒",
  sweetness: 0.5,
  richness: 1.0
}

// 結果: 新規追加対象
```

## 5. パフォーマンス分析

### 計算コスト
```javascript
// 3,167件のデータに対して
// 1. ハッシュ計算: 3,167回
// 2. 文字列比較: 3,167回
// 合計処理時間: 約100-200ms（高速）

// 従来の全フィールド比較の場合
// 1. フィールド比較: 3,167 × 10フィールド = 31,670回
// 合計処理時間: 約500-1000ms（遅い）
```

### メモリ効率
```javascript
// ハッシュ方式
// 保存データ: 64バイト/レコード
// 合計: 3,167 × 64 = 約200KB

// 全データコピー方式
// 保存データ: 約500バイト/レコード
// 合計: 3,167 × 500 = 約1.5MB
```

## 6. 利点と注意点

### 利点
1. **高速比較**: 64文字の文字列比較1回で済む
2. **確実性**: データが1バイトでも違えば検出
3. **効率的**: 不要な更新を完全に排除
4. **監査対応**: ハッシュ値自体が変更の証跡

### 注意点
1. **小数点の扱い**
```javascript
// 浮動小数点の誤差対策
sweetness: Math.round(record.sweetness * 1000) / 1000
// 1.4999999999 → 1.500 に正規化
```

2. **フィールド追加時**
```javascript
// 新しいフィールドを追加する場合
const dataForHash = {
  ...既存フィールド,
  new_field: record.new_field  // ハッシュ計算に追加
};
// 全レコードのハッシュが変わるため、全更新になる
```

3. **ハッシュの再計算**
```javascript
// マイグレーション時の考慮
// 1. 新フィールド追加
// 2. 全レコードのハッシュ再計算が必要
// 3. 初回は全件更新になることを許容
```

## 7. デバッグ方法

### ハッシュ値の確認
```sql
-- 特定の銘柄のハッシュ値を確認
SELECT brand_id, brand_name, data_hash
FROM sake_master
WHERE brand_name LIKE '%獺祭%';
```

### 変更履歴の確認
```sql
-- 特定銘柄の変更履歴
SELECT 
  generation_id,
  operation,
  changed_fields,
  changed_at
FROM sake_master_history
WHERE brand_id = 1
ORDER BY changed_at DESC;
```

### ハッシュ不一致の調査
```javascript
// デバッグ用: どのフィールドが変更されたか詳細表示
function debugHashDifference(oldRecord, newRecord) {
  const fields = ['brand_name', 'brewery_name', 'sweetness', ...];
  
  for (const field of fields) {
    if (oldRecord[field] !== newRecord[field]) {
      console.log(`Field changed: ${field}`);
      console.log(`  Old: ${oldRecord[field]}`);
      console.log(`  New: ${newRecord[field]}`);
    }
  }
}
```

## 8. 実運用での活用例

### 日次レポート
```javascript
// 変更サマリーの生成
const generateDailyReport = async (generationId) => {
  const changes = await supabase
    .from('sake_master_history')
    .select('operation, brand_id, changed_fields')
    .eq('generation_id', generationId);
  
  return {
    date: new Date(),
    summary: {
      total_checked: 3167,
      changed: changes.length,
      unchanged: 3167 - changes.length,
      change_rate: `${(changes.length / 3167 * 100).toFixed(2)}%`
    }
  };
};
```

### 異常検知
```javascript
// 大量変更の検知（データソースの問題の可能性）
if (changes.updates.length > 1000) {
  console.warn('⚠️ 異常な変更数を検知。APIの仕様変更の可能性があります。');
  // 管理者に通知
  await notifyAdmin('Large number of changes detected');
}
```

## まとめ

SHA256ハッシュによる差分検出は：
- **効率的**: 1回の比較で全フィールドの変更を検出
- **確実**: 微小な変更も見逃さない
- **高速**: 3,000件でも200ms以内で処理
- **実用的**: 不要なDB更新を完全に排除

この仕組みにより、毎日のバッチ処理で**本当に変更があったデータだけ**を更新し、システムの負荷を最小限に抑えながら、データの整合性を保つことができます。