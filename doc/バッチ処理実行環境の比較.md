# バッチ処理実行環境の比較：GitHub Actions vs Vercel Cron

## 📊 詳細比較表

| 項目 | GitHub Actions | Vercel Cron |
|------|---------------|-------------|
| **料金** | ✅ 無料（2,000分/月） | ❌ 有料（Pro: $20/月〜） |
| **実行時間制限** | ✅ 最大6時間 | ❌ 10秒〜5分 |
| **データ処理** | ✅ 3,167件処理可能 | ⚠️ タイムアウトリスク |
| **設定の簡単さ** | ✅ YAMLファイル | ⚠️ API実装必要 |
| **ログ・監視** | ✅ 詳細なログUI | ⚠️ 基本的なログ |
| **エラー通知** | ✅ 多様な通知方法 | ⚠️ 限定的 |
| **リトライ** | ✅ 自動リトライ可能 | ❌ 手動実装必要 |
| **環境変数** | ✅ Secrets管理 | ✅ 環境変数対応 |

## 🎯 **推奨：GitHub Actions**

### 決定的な理由

#### 1. 💰 コスト優位性
```
GitHub Actions: $0（無料枠で十分）
- 必要時間: 5分/日 × 30日 = 150分/月
- 無料枠: 2,000分/月
- 余裕度: 13倍

Vercel Cron: $20/月〜
- Pro Plan必須
- 追加コストが発生
```

#### 2. ⏱️ 実行時間の余裕
```
想定処理時間: 3-5分
- API取得: 1分
- データ変換: 1分
- DB更新: 2-3分

GitHub Actions: ✅ 6時間まで余裕
Vercel Cron: ❌ 5分でギリギリ
```

#### 3. 🔧 実装の柔軟性
GitHub Actionsなら：
- Node.js、Python、任意の言語で実装可能
- 複数ステップの分割実行
- 条件分岐やエラーハンドリングが豊富

## 実装例

### GitHub Actions（推奨）

```yaml
# .github/workflows/sync-sake-data.yml
name: Sync Sake Data from Sakenowa API

on:
  schedule:
    # 毎日 AM 2:00 JST (前日 17:00 UTC)
    - cron: '0 17 * * *'
  
  # 手動実行も可能
  workflow_dispatch:
    inputs:
      force_full_sync:
        description: 'Force full data sync'
        required: false
        default: 'false'

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # タイムアウト設定
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci --only=production
      
      - name: Run sync script
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        run: |
          node scripts/sync-sake-data.js
      
      - name: Upload sync report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sync-report-${{ github.run_id }}
          path: logs/sync-*.json
          retention-days: 30
      
      - name: Notify on failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: '🚨 Sake data sync failed!'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### 同期スクリプト（scripts/sync-sake-data.js）

```javascript
// scripts/sync-sake-data.js
import { createClient } from '@supabase/supabase-js';
import fs from 'fs/promises';

class SakeDataSynchronizer {
  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_KEY
    );
    this.stats = {
      startTime: new Date(),
      processed: 0,
      inserted: 0,
      updated: 0,
      errors: []
    };
  }

  async run() {
    console.log('🍶 Starting Sake data sync...');
    
    try {
      // 1. 同期開始をログに記録
      await this.logSyncStart();
      
      // 2. さけのわAPIからデータ取得
      console.log('📥 Fetching data from Sakenowa API...');
      const data = await this.fetchAllData();
      console.log(`✅ Fetched ${data.length} sake records`);
      
      // 3. データ変換とベクトル化
      console.log('🔄 Transforming data...');
      const transformed = await this.transformData(data);
      
      // 4. バッチ更新（500件ずつ）
      console.log('💾 Updating database...');
      await this.batchUpsert(transformed);
      
      // 5. 統計情報を保存
      await this.saveStats();
      
      console.log('✅ Sync completed successfully!');
      console.log(this.stats);
      
    } catch (error) {
      console.error('❌ Sync failed:', error);
      this.stats.errors.push(error.message);
      await this.logSyncError(error);
      process.exit(1);
    }
  }

  async fetchAllData() {
    const [brands, breweries, flavorCharts] = await Promise.all([
      fetch('https://muro.sakenowa.com/sakenowa-data/api/brands')
        .then(r => r.json()),
      fetch('https://muro.sakenowa.com/sakenowa-data/api/breweries')
        .then(r => r.json()),
      fetch('https://muro.sakenowa.com/sakenowa-data/api/flavor-charts')
        .then(r => r.json())
    ]);

    return this.mergeData(brands.brands, breweries.breweries, flavorCharts.flavorCharts);
  }

  async batchUpsert(data, batchSize = 500) {
    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      
      const { error } = await this.supabase
        .from('sake_master')
        .upsert(batch, {
          onConflict: 'brand_id',
          ignoreDuplicates: false
        });

      if (error) {
        this.stats.errors.push(`Batch ${i}: ${error.message}`);
        throw error;
      }

      this.stats.processed += batch.length;
      console.log(`Progress: ${this.stats.processed}/${data.length}`);
    }
  }

  async saveStats() {
    const report = {
      ...this.stats,
      endTime: new Date(),
      duration: Date.now() - this.stats.startTime.getTime()
    };

    // ローカルログ保存
    await fs.writeFile(
      `logs/sync-${Date.now()}.json`,
      JSON.stringify(report, null, 2)
    );

    // Supabaseに同期ログ保存
    await this.supabase
      .from('sync_logs')
      .insert({
        sync_type: 'full',
        total_records: this.stats.processed,
        inserted_count: this.stats.inserted,
        updated_count: this.stats.updated,
        error_count: this.stats.errors.length,
        status: 'completed'
      });
  }
}

// 実行
const sync = new SakeDataSynchronizer();
sync.run();
```

### Vercel Cron（非推奨だが参考）

```typescript
// app/api/cron/sync-sake/route.ts
import { NextResponse } from 'next/server';

export const maxDuration = 300; // 5分（Pro Planのみ）

export async function GET(request: Request) {
  // セキュリティ: Cron Secret検証
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('Unauthorized', { status: 401 });
  }

  try {
    // 注意: 5分以内に完了する必要がある
    const result = await syncSakeData();
    return NextResponse.json({ success: true, ...result });
  } catch (error) {
    // エラー時も5分でタイムアウト
    return NextResponse.json({ success: false, error }, { status: 500 });
  }
}
```

```json
// vercel.json
{
  "crons": [{
    "path": "/api/cron/sync-sake",
    "schedule": "0 17 * * *"  // 毎日 AM 2:00 JST
  }]
}
```

## 📊 シナリオ別の推奨

### ケース1: 標準的な日本酒アプリ（推奨シナリオ）
**→ GitHub Actions**
- 3,167件のデータ処理に余裕
- 無料で運用可能
- 詳細なログとエラーハンドリング

### ケース2: 既にVercel Proを使用中
**→ それでもGitHub Actions推奨**
- 実行時間の制約がきつい
- バッチ処理には不向き

### ケース3: リアルタイム性が必要
**→ 別の方式を検討**
- Webhookベースの更新
- イベントドリブンアーキテクチャ

## 🚀 実装手順（GitHub Actions）

### Step 1: Secretsの設定
```bash
# GitHubリポジトリ設定 > Secrets and variables > Actions
SUPABASE_URL=your-project-url
SUPABASE_SERVICE_KEY=your-service-key
SLACK_WEBHOOK=your-webhook-url  # オプション
```

### Step 2: スクリプト作成
```bash
mkdir -p scripts logs
touch scripts/sync-sake-data.js
```

### Step 3: ワークフロー作成
```bash
mkdir -p .github/workflows
touch .github/workflows/sync-sake-data.yml
```

### Step 4: テスト実行
```bash
# ローカルでテスト
node scripts/sync-sake-data.js

# GitHub Actionsで手動実行
# Actions タブ > Sync Sake Data > Run workflow
```

## 監視とアラート

### GitHub Actions の監視機能
- ✅ 実行履歴の可視化
- ✅ 失敗時の自動通知（メール）
- ✅ Slack/Discord連携可能
- ✅ 詳細なログ保存（30日間）

### 推奨監視設定
```yaml
# エラー時のみSlack通知
- name: Notify on failure
  if: failure()
  run: |
    curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
      -H 'Content-Type: application/json' \
      -d '{
        "text": "🚨 Sake sync failed!",
        "blocks": [{
          "type": "section",
          "text": {
            "type": "mrkdwn",
            "text": "*Sync Failed*\nRun: ${{ github.run_id }}\nError: Check logs"
          }
        }]
      }'
```

## 結論

### 🏆 **GitHub Actions を強く推奨**

理由：
1. **無料** で十分な実行時間
2. **6時間**の余裕ある制限
3. **豊富な機能**と柔軟性
4. **実績のある**バッチ処理環境

Vercel Cronは：
- Webアプリ内の軽量タスク向け
- 大量データ処理には不適切
- コストパフォーマンスが悪い