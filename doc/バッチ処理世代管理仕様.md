# バッチ処理世代管理仕様書

## 概要
さけのわAPIから取得したデータの変更を追跡し、履歴を保持する世代管理システムの設計。

## 世代管理の要件

### 機能要件
1. **差分検出**: 変更があったレコードのみを更新
2. **履歴保存**: 全ての変更履歴を保持
3. **世代番号**: 各同期実行を世代として管理
4. **ロールバック**: 任意の世代に戻せる機能
5. **変更通知**: 重要な変更を検知して通知

### 非機能要件
- ストレージ効率: 差分のみ保存でストレージ節約
- パフォーマンス: 大量データでも高速処理
- 監査対応: いつ、何が変更されたか追跡可能

## データベース設計

### 1. メインテーブル（現在のデータ）
```sql
-- 現在有効なデータ（既存設計を拡張）
CREATE TABLE sake_master (
  id VARCHAR(50) PRIMARY KEY,
  brand_id INTEGER NOT NULL UNIQUE,
  brand_name VARCHAR(255) NOT NULL,
  brewery_id INTEGER NOT NULL,
  brewery_name VARCHAR(255) NOT NULL,
  
  -- 味わいデータ
  sweetness FLOAT DEFAULT 0,
  richness FLOAT DEFAULT 0,
  f1_floral FLOAT DEFAULT 0.5,
  f2_mellow FLOAT DEFAULT 0.5,
  f3_heavy FLOAT DEFAULT 0.5,
  f4_mild FLOAT DEFAULT 0.5,
  f5_dry FLOAT DEFAULT 0.5,
  f6_light FLOAT DEFAULT 0.5,
  
  -- 世代管理用
  generation_id INTEGER NOT NULL,
  data_hash VARCHAR(64) NOT NULL, -- データのSHA256ハッシュ
  is_active BOOLEAN DEFAULT true,
  
  -- メタデータ
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  deleted_at TIMESTAMP,
  
  INDEX idx_generation (generation_id),
  INDEX idx_active (is_active),
  INDEX idx_data_hash (data_hash)
);
```

### 2. 履歴テーブル（全ての変更履歴）
```sql
-- 変更履歴を保存
CREATE TABLE sake_master_history (
  history_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- 元データの識別子
  brand_id INTEGER NOT NULL,
  generation_id INTEGER NOT NULL,
  
  -- 変更タイプ
  operation VARCHAR(10) NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'
  
  -- 変更前データ（JSONで保存）
  old_data JSONB,
  
  -- 変更後データ（JSONで保存）
  new_data JSONB,
  
  -- 変更されたフィールドのリスト
  changed_fields TEXT[],
  
  -- メタデータ
  changed_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_brand_generation (brand_id, generation_id),
  INDEX idx_operation (operation),
  INDEX idx_changed_at (changed_at DESC)
);
```

### 3. 世代管理テーブル
```sql
-- 同期実行の世代を管理
CREATE TABLE sync_generations (
  generation_id SERIAL PRIMARY KEY,
  
  -- 同期情報
  sync_started_at TIMESTAMP NOT NULL,
  sync_completed_at TIMESTAMP,
  sync_status VARCHAR(20) DEFAULT 'running', -- running, completed, failed
  
  -- 統計情報
  total_records INTEGER DEFAULT 0,
  inserted_count INTEGER DEFAULT 0,
  updated_count INTEGER DEFAULT 0,
  deleted_count INTEGER DEFAULT 0,
  unchanged_count INTEGER DEFAULT 0,
  
  -- データソース情報
  api_snapshot JSONB, -- APIレスポンスのメタデータ
  
  -- エラー情報
  error_message TEXT,
  error_details JSONB,
  
  INDEX idx_sync_status (sync_status),
  INDEX idx_sync_completed (sync_completed_at DESC)
);
```

### 4. 変更サマリーテーブル
```sql
-- 世代間の変更サマリー
CREATE TABLE generation_changes_summary (
  summary_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  generation_id INTEGER REFERENCES sync_generations(generation_id),
  
  -- 主要な変更
  new_brands TEXT[], -- 新規追加された銘柄
  removed_brands TEXT[], -- 削除された銘柄
  major_changes JSONB, -- 大きな変更のサマリー
  
  -- 変更の影響度
  change_impact VARCHAR(20), -- 'minor', 'moderate', 'major'
  
  -- 通知フラグ
  notification_sent BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP DEFAULT NOW()
);
```

## 差分検出アルゴリズム

### 実装方針
```javascript
class DifferentialSync {
  /**
   * データの差分を検出して更新
   */
  async detectAndApplyChanges(newData, currentGeneration) {
    const currentData = await this.getCurrentData();
    const changes = {
      inserts: [],
      updates: [],
      deletes: []
    };

    // 1. 新規・更新の検出
    for (const newRecord of newData) {
      const currentRecord = currentData.get(newRecord.brand_id);
      
      if (!currentRecord) {
        // 新規レコード
        changes.inserts.push(newRecord);
      } else {
        // ハッシュ比較で変更検出
        const newHash = this.calculateHash(newRecord);
        const currentHash = currentRecord.data_hash;
        
        if (newHash !== currentHash) {
          // 変更されたフィールドを特定
          const changedFields = this.detectChangedFields(
            currentRecord, 
            newRecord
          );
          
          changes.updates.push({
            record: newRecord,
            oldRecord: currentRecord,
            changedFields
          });
        }
      }
    }

    // 2. 削除の検出
    const newBrandIds = new Set(newData.map(r => r.brand_id));
    for (const [brandId, record] of currentData) {
      if (!newBrandIds.has(brandId)) {
        changes.deletes.push(record);
      }
    }

    // 3. 変更を適用
    await this.applyChanges(changes, currentGeneration);
    
    return changes;
  }

  /**
   * SHA256ハッシュを計算
   */
  calculateHash(record) {
    const crypto = require('crypto');
    const dataString = JSON.stringify({
      brand_name: record.brand_name,
      brewery_name: record.brewery_name,
      sweetness: record.sweetness,
      richness: record.richness,
      f1: record.f1_floral,
      f2: record.f2_mellow,
      f3: record.f3_heavy,
      f4: record.f4_mild,
      f5: record.f5_dry,
      f6: record.f6_light
    });
    
    return crypto
      .createHash('sha256')
      .update(dataString)
      .digest('hex');
  }

  /**
   * 変更されたフィールドを検出
   */
  detectChangedFields(oldRecord, newRecord) {
    const fields = [
      'brand_name', 'brewery_name', 'sweetness', 'richness',
      'f1_floral', 'f2_mellow', 'f3_heavy', 'f4_mild', 'f5_dry', 'f6_light'
    ];
    
    return fields.filter(field => 
      oldRecord[field] !== newRecord[field]
    );
  }
}
```

## バッチ処理スクリプト

### メインスクリプト（scripts/sync-sake-data-with-history.js）
```javascript
import { createClient } from '@supabase/supabase-js';
import crypto from 'crypto';

class SakeDataSyncWithHistory {
  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_KEY
    );
  }

  async run() {
    let generation = null;
    
    try {
      // 1. 新しい世代を開始
      generation = await this.startNewGeneration();
      console.log(`🔄 Started generation #${generation.generation_id}`);
      
      // 2. APIからデータ取得
      const apiData = await this.fetchFromSakenowaAPI();
      
      // 3. 現在のデータを取得
      const currentData = await this.getCurrentMasterData();
      
      // 4. 差分検出
      const changes = await this.detectChanges(apiData, currentData);
      console.log(`📊 Changes detected:`, {
        new: changes.inserts.length,
        updated: changes.updates.length,
        deleted: changes.deletes.length
      });
      
      // 5. 変更を適用
      if (this.hasChanges(changes)) {
        await this.applyChangesWithHistory(changes, generation);
        
        // 6. 重要な変更を通知
        await this.notifyImportantChanges(changes, generation);
      }
      
      // 7. 世代を完了
      await this.completeGeneration(generation, changes);
      
      console.log(`✅ Generation #${generation.generation_id} completed`);
      
    } catch (error) {
      console.error('❌ Sync failed:', error);
      if (generation) {
        await this.failGeneration(generation, error);
      }
      throw error;
    }
  }

  async detectChanges(apiData, currentData) {
    const currentMap = new Map(
      currentData.map(r => [r.brand_id, r])
    );
    
    const changes = {
      inserts: [],
      updates: [],
      deletes: []
    };
    
    // 新規・更新の検出
    for (const apiRecord of apiData) {
      const current = currentMap.get(apiRecord.brand_id);
      
      if (!current) {
        changes.inserts.push(apiRecord);
      } else {
        const apiHash = this.calculateHash(apiRecord);
        if (apiHash !== current.data_hash) {
          changes.updates.push({
            old: current,
            new: apiRecord,
            changedFields: this.getChangedFields(current, apiRecord)
          });
        }
        currentMap.delete(apiRecord.brand_id);
      }
    }
    
    // 削除の検出（APIに存在しないレコード）
    changes.deletes = Array.from(currentMap.values());
    
    return changes;
  }

  async applyChangesWithHistory(changes, generation) {
    const { generation_id } = generation;
    
    // トランザクション内で実行
    const promises = [];
    
    // 新規追加
    for (const record of changes.inserts) {
      promises.push(this.insertWithHistory(record, generation_id));
    }
    
    // 更新
    for (const update of changes.updates) {
      promises.push(this.updateWithHistory(
        update.old, 
        update.new, 
        update.changedFields,
        generation_id
      ));
    }
    
    // 削除（論理削除）
    for (const record of changes.deletes) {
      promises.push(this.deleteWithHistory(record, generation_id));
    }
    
    await Promise.all(promises);
  }

  async insertWithHistory(record, generationId) {
    const hash = this.calculateHash(record);
    
    // マスターテーブルに挿入
    await this.supabase
      .from('sake_master')
      .insert({
        ...record,
        generation_id: generationId,
        data_hash: hash,
        is_active: true
      });
    
    // 履歴テーブルに記録
    await this.supabase
      .from('sake_master_history')
      .insert({
        brand_id: record.brand_id,
        generation_id: generationId,
        operation: 'INSERT',
        old_data: null,
        new_data: record,
        changed_fields: Object.keys(record)
      });
  }

  async updateWithHistory(oldRecord, newRecord, changedFields, generationId) {
    const hash = this.calculateHash(newRecord);
    
    // マスターテーブルを更新
    await this.supabase
      .from('sake_master')
      .update({
        ...newRecord,
        generation_id: generationId,
        data_hash: hash,
        updated_at: new Date()
      })
      .eq('brand_id', newRecord.brand_id);
    
    // 履歴テーブルに記録
    await this.supabase
      .from('sake_master_history')
      .insert({
        brand_id: newRecord.brand_id,
        generation_id: generationId,
        operation: 'UPDATE',
        old_data: oldRecord,
        new_data: newRecord,
        changed_fields: changedFields
      });
  }

  async deleteWithHistory(record, generationId) {
    // 論理削除
    await this.supabase
      .from('sake_master')
      .update({
        is_active: false,
        deleted_at: new Date(),
        generation_id: generationId
      })
      .eq('brand_id', record.brand_id);
    
    // 履歴テーブルに記録
    await this.supabase
      .from('sake_master_history')
      .insert({
        brand_id: record.brand_id,
        generation_id: generationId,
        operation: 'DELETE',
        old_data: record,
        new_data: null,
        changed_fields: []
      });
  }

  calculateHash(record) {
    const dataString = JSON.stringify({
      brand_name: record.brand_name,
      brewery_name: record.brewery_name,
      sweetness: record.sweetness,
      richness: record.richness,
      f1: record.f1_floral,
      f2: record.f2_mellow,
      f3: record.f3_heavy,
      f4: record.f4_mild,
      f5: record.f5_dry,
      f6: record.f6_light
    });
    
    return crypto
      .createHash('sha256')
      .update(dataString)
      .digest('hex');
  }
}

// 実行
const sync = new SakeDataSyncWithHistory();
sync.run().catch(console.error);
```

## GitHub Actions ワークフロー

```yaml
# .github/workflows/sync-sake-data-with-history.yml
name: Sync Sake Data with History

on:
  schedule:
    # 毎日 AM 2:00 JST
    - cron: '0 17 * * *'
  
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (no changes)'
        required: false
        default: 'false'

jobs:
  sync:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci --production
      
      - name: Run sync with history
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          node scripts/sync-sake-data-with-history.js
      
      - name: Generate change report
        if: always()
        run: |
          node scripts/generate-change-report.js > change-report.md
      
      - name: Upload reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sync-reports-${{ github.run_id }}
          path: |
            change-report.md
            logs/*.json
          retention-days: 90
      
      - name: Notify significant changes
        if: success()
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        run: |
          node scripts/notify-changes.js
```

## 世代管理の利点

### 1. 変更追跡
- いつ、何が変更されたか完全に追跡可能
- 特定の銘柄の変更履歴を確認可能

### 2. ロールバック機能
```sql
-- 特定の世代に戻す
UPDATE sake_master
SET is_active = false
WHERE generation_id > :target_generation;

-- 削除されたレコードを復活
UPDATE sake_master
SET is_active = true, deleted_at = NULL
WHERE generation_id <= :target_generation
  AND brand_id IN (
    SELECT brand_id FROM sake_master_history
    WHERE generation_id = :target_generation
    AND operation != 'DELETE'
  );
```

### 3. 分析・監査
```sql
-- 最近の大きな変更を確認
SELECT 
  g.generation_id,
  g.sync_completed_at,
  COUNT(CASE WHEN h.operation = 'INSERT' THEN 1 END) as new_items,
  COUNT(CASE WHEN h.operation = 'UPDATE' THEN 1 END) as updated_items,
  COUNT(CASE WHEN h.operation = 'DELETE' THEN 1 END) as deleted_items
FROM sync_generations g
JOIN sake_master_history h ON g.generation_id = h.generation_id
WHERE g.sync_completed_at > NOW() - INTERVAL '7 days'
GROUP BY g.generation_id, g.sync_completed_at
ORDER BY g.sync_completed_at DESC;
```

### 4. 効率的なストレージ
- 変更がない場合は履歴を作成しない
- JSONBで差分のみを保存
- 古い履歴は定期的にアーカイブ可能

## 実装優先順位

1. **Phase 1**: 基本的な差分検出と履歴保存（1日）
2. **Phase 2**: 世代管理とロールバック機能（1日）
3. **Phase 3**: 変更通知と監視機能（0.5日）
4. **Phase 4**: レポート生成と分析機能（0.5日）