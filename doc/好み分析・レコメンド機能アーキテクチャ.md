# 好み分析・レコメンド機能 - アーキテクチャ設計

## 概要
TypeScriptベースのロジックで実装する好み分析・レコメンドシステム。
生成AIは不要で、統計的手法と類似度計算で十分な精度を実現可能。

## アーキテクチャ全体像

```
┌─────────────────────────────────────────────────┐
│                  フロントエンド                    │
│                   (Next.js)                      │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────┐  ┌──────────────┐           │
│  │ Preference   │  │ Recommend    │           │
│  │ Dashboard    │  │   Display    │           │
│  └──────────────┘  └──────────────┘           │
│          ↓                ↓                    │
│  ┌─────────────────────────────────┐          │
│  │   Recommendation Service         │          │
│  │   (クライアントサイド処理)         │          │
│  └─────────────────────────────────┘          │
│          ↓                                     │
│  ┌──────────────┐  ┌──────────────┐          │
│  │ Preference   │  │ Recommendation│          │
│  │  Analyzer    │→ │   Engine      │          │
│  └──────────────┘  └──────────────┘          │
│          ↓                ↓                    │
├─────────────────────────────────────────────────┤
│                  バックエンド                     │
│               (Supabase/API)                    │
├─────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐          │
│  │  Favorites   │  │   Sake       │          │
│  │   Table      │  │  Master      │          │
│  └──────────────┘  └──────────────┘          │
│  ┌──────────────┐  ┌──────────────┐          │
│  │  Preferences │  │ Recommendations│         │
│  │   Cache      │  │    Cache      │          │
│  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────┘
```

## コンポーネント設計

### 1. データ層

#### Supabaseテーブル設計

```sql
-- ユーザー好み分析結果（キャッシュ）
CREATE TABLE user_preferences (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- 好みベクトル
  sweetness_preference FLOAT DEFAULT 0,  -- -5 to +5
  richness_preference FLOAT DEFAULT 0,   -- -5 to +5
  
  -- 6要素の好み（0-1で正規化）
  f1_preference FLOAT DEFAULT 0.5,
  f2_preference FLOAT DEFAULT 0.5,
  f3_preference FLOAT DEFAULT 0.5,
  f4_preference FLOAT DEFAULT 0.5,
  f5_preference FLOAT DEFAULT 0.5,
  f6_preference FLOAT DEFAULT 0.5,
  
  -- メタデータ
  taste_type VARCHAR(50),
  diversity_score FLOAT DEFAULT 0,
  adventure_score FLOAT DEFAULT 0,
  total_favorites INT DEFAULT 0,
  
  -- 更新管理
  calculated_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id)
);

-- レコメンド結果キャッシュ
CREATE TABLE recommendation_cache (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  sake_id VARCHAR(255),
  
  -- スコア
  similarity_score FLOAT,
  predicted_rating FLOAT,
  recommendation_type VARCHAR(50), -- 'similar', 'explore', 'trending'
  
  -- メタデータ
  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP,
  
  INDEX idx_user_recommendations (user_id, similarity_score DESC)
);
```

### 2. ビジネスロジック層

#### TypeScriptの実装構造

```typescript
// types/preference.ts
export interface PreferenceVector {
  sweetness: number;
  richness: number;
  f1_floral: number;
  f2_mellow: number;
  f3_heavy: number;
  f4_mild: number;
  f5_dry: number;
  f6_light: number;
}

export interface UserPreference {
  userId: string;
  vector: PreferenceVector;
  tasteType: TasteType;
  diversityScore: number;
  adventureScore: number;
  calculatedAt: Date;
}

export type TasteType = 
  | 'floral'     // 華やか系
  | 'mellow'     // まろやか系
  | 'heavy'      // 重厚系
  | 'mild'       // 穏やか系
  | 'dry'        // キレ系
  | 'light'      // 軽快系
  | 'balanced'   // バランス型
  | 'explorer';  // 冒険家型
```

#### 好み分析サービス

```typescript
// services/preferenceAnalyzer.ts
export class PreferenceAnalyzer {
  /**
   * お気に入りリストから好みベクトルを計算
   */
  calculatePreferenceVector(favorites: Sake[]): PreferenceVector {
    if (favorites.length === 0) {
      return this.getDefaultVector();
    }

    // 重み付き平均の計算
    const weights = this.calculateWeights(favorites);
    const weightedSum = this.calculateWeightedSum(favorites, weights);
    
    return this.normalizeVector(weightedSum);
  }

  /**
   * 重みの計算（最近のものほど重視）
   */
  private calculateWeights(favorites: Sake[]): number[] {
    const now = Date.now();
    return favorites.map(sake => {
      const age = now - new Date(sake.createdAt).getTime();
      const daysSince = age / (1000 * 60 * 60 * 24);
      // 指数関数的減衰（半減期30日）
      return Math.exp(-daysSince / 30);
    });
  }

  /**
   * 味覚タイプの判定
   */
  determineTasteType(vector: PreferenceVector): TasteType {
    const scores = {
      floral: vector.f1_floral,
      mellow: vector.f2_mellow,
      heavy: vector.f3_heavy,
      mild: vector.f4_mild,
      dry: vector.f5_dry,
      light: vector.f6_light
    };

    // 最も高いスコアのタイプを選択
    const maxScore = Math.max(...Object.values(scores));
    const dominantType = Object.entries(scores)
      .find(([_, score]) => score === maxScore)?.[0];

    // バランス型の判定（標準偏差が小さい場合）
    const stdDev = this.calculateStandardDeviation(Object.values(scores));
    if (stdDev < 0.15) return 'balanced';

    return dominantType as TasteType;
  }

  /**
   * 多様性スコアの計算
   */
  calculateDiversityScore(favorites: Sake[]): number {
    if (favorites.length < 2) return 0;

    // 各日本酒間の距離を計算
    const distances: number[] = [];
    for (let i = 0; i < favorites.length; i++) {
      for (let j = i + 1; j < favorites.length; j++) {
        distances.push(this.calculateDistance(favorites[i], favorites[j]));
      }
    }

    // 平均距離を0-1に正規化
    const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
    return Math.min(avgDistance / 5, 1); // 最大距離5で正規化
  }
}
```

#### レコメンドエンジン

```typescript
// services/recommendationEngine.ts
export class RecommendationEngine {
  /**
   * レコメンドの生成
   */
  async generateRecommendations(
    userPreference: UserPreference,
    allSakes: Sake[],
    options: RecommendOptions
  ): Promise<Recommendation[]> {
    const recommendations: Recommendation[] = [];

    // 1. 類似性ベースのレコメンド（70%）
    const similarSakes = this.findSimilarSakes(
      userPreference.vector,
      allSakes,
      options.count * 0.7
    );
    recommendations.push(...similarSakes);

    // 2. 探索的レコメンド（20%）
    const exploreSakes = this.findExploratorySakes(
      userPreference,
      allSakes,
      options.count * 0.2
    );
    recommendations.push(...exploreSakes);

    // 3. トレンドベース（10%）
    const trendingSakes = await this.findTrendingSakes(
      options.count * 0.1
    );
    recommendations.push(...trendingSakes);

    return this.rankAndFilter(recommendations, options);
  }

  /**
   * コサイン類似度の計算
   */
  private calculateSimilarity(
    vector1: PreferenceVector,
    sake: Sake
  ): number {
    const vector2 = this.sakeToVector(sake);
    
    // コサイン類似度
    const dotProduct = this.dotProduct(vector1, vector2);
    const magnitude1 = this.magnitude(vector1);
    const magnitude2 = this.magnitude(vector2);
    
    if (magnitude1 === 0 || magnitude2 === 0) return 0;
    return dotProduct / (magnitude1 * magnitude2);
  }

  /**
   * 探索的レコメンド（好みと異なるものを提案）
   */
  private findExploratorySakes(
    userPreference: UserPreference,
    sakes: Sake[],
    count: number
  ): Recommendation[] {
    // 冒険度スコアに応じて探索範囲を調整
    const explorationRadius = 2 + userPreference.adventureScore * 3;
    
    return sakes
      .filter(sake => {
        const distance = this.calculateDistance(
          userPreference.vector,
          this.sakeToVector(sake)
        );
        // 適度に離れたものを選択
        return distance > explorationRadius && distance < explorationRadius + 2;
      })
      .map(sake => ({
        sake,
        score: this.calculateNoveltyScore(sake, userPreference),
        type: 'explore' as const,
        reason: '新しい味わいの発見'
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, count);
  }

  /**
   * 気分別レコメンド
   */
  getMoodBasedRecommendations(
    mood: 'usual' | 'adventure' | 'discovery' | 'special',
    userPreference: UserPreference,
    sakes: Sake[]
  ): Recommendation[] {
    switch (mood) {
      case 'usual':
        // 好みゾーン内から安定した選択
        return this.findSimilarSakes(userPreference.vector, sakes, 10);
      
      case 'adventure':
        // 好みゾーンの境界付近
        return this.findBorderlineSakes(userPreference, sakes);
      
      case 'discovery':
        // 全く新しいゾーン
        return this.findOppositeSakes(userPreference, sakes);
      
      case 'special':
        // プレミアム＆高評価
        return this.findPremiumSakes(sakes);
    }
  }
}
```

### 3. プレゼンテーション層

#### React Hooks

```typescript
// hooks/usePreferenceAnalysis.ts
export function usePreferenceAnalysis() {
  const { favorites } = useFavorites();
  const [preference, setPreference] = useState<UserPreference | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (favorites.length > 0) {
      analyzePreferences();
    }
  }, [favorites]);

  const analyzePreferences = async () => {
    setLoading(true);
    try {
      const analyzer = new PreferenceAnalyzer();
      const vector = analyzer.calculatePreferenceVector(favorites);
      const tasteType = analyzer.determineTasteType(vector);
      const diversityScore = analyzer.calculateDiversityScore(favorites);
      
      const userPref: UserPreference = {
        userId: user.id,
        vector,
        tasteType,
        diversityScore,
        adventureScore: calculateAdventureScore(favorites),
        calculatedAt: new Date()
      };
      
      // Supabaseに保存
      await saveUserPreference(userPref);
      setPreference(userPref);
    } finally {
      setLoading(false);
    }
  };

  return { preference, loading, refresh: analyzePreferences };
}

// hooks/useRecommendations.ts
export function useRecommendations(options?: RecommendOptions) {
  const { preference } = usePreferenceAnalysis();
  const [recommendations, setRecommendations] = useState<Recommendation[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (preference) {
      loadRecommendations();
    }
  }, [preference]);

  const loadRecommendations = async () => {
    setLoading(true);
    try {
      // キャッシュチェック
      const cached = await getCachedRecommendations(preference.userId);
      if (cached && !isExpired(cached)) {
        setRecommendations(cached);
        return;
      }

      // 新規生成
      const engine = new RecommendationEngine();
      const allSakes = await fetchAllSakes();
      const recs = await engine.generateRecommendations(
        preference,
        allSakes,
        options || { count: 20 }
      );
      
      // キャッシュ保存
      await cacheRecommendations(preference.userId, recs);
      setRecommendations(recs);
    } finally {
      setLoading(false);
    }
  };

  return { recommendations, loading, refresh: loadRecommendations };
}
```

## パフォーマンス最適化

### 1. キャッシュ戦略
- **好み分析結果**: 24時間キャッシュ
- **レコメンド結果**: 12時間キャッシュ
- **インクリメンタル更新**: お気に入り追加時は差分計算

### 2. 計算の最適化
```typescript
// 事前計算とインデックス
class OptimizedRecommendationEngine {
  private sakeVectorCache: Map<string, PreferenceVector>;
  private similarityMatrix: Map<string, Map<string, number>>;

  constructor() {
    this.sakeVectorCache = new Map();
    this.similarityMatrix = new Map();
  }

  // バッチ処理で類似度行列を事前計算
  async precomputeSimilarityMatrix(sakes: Sake[]) {
    for (const sake1 of sakes) {
      const vector1 = this.getSakeVector(sake1);
      const similarities = new Map<string, number>();
      
      for (const sake2 of sakes) {
        if (sake1.id !== sake2.id) {
          const vector2 = this.getSakeVector(sake2);
          similarities.set(sake2.id, this.cosineSimilarity(vector1, vector2));
        }
      }
      
      this.similarityMatrix.set(sake1.id, similarities);
    }
  }
}
```

### 3. Progressive Enhancement
```typescript
// 段階的な結果表示
async function* generateProgressiveRecommendations(
  preference: UserPreference,
  sakes: Sake[]
): AsyncGenerator<Recommendation[]> {
  // Step 1: 即座に表示（キャッシュから）
  const cached = await getCachedRecommendations(preference.userId);
  if (cached) yield cached;

  // Step 2: 高速な類似度計算（上位10件）
  const quickRecs = await quickSimilaritySearch(preference, sakes, 10);
  yield quickRecs;

  // Step 3: 完全な計算（全件）
  const fullRecs = await fullRecommendationEngine(preference, sakes);
  yield fullRecs;
}
```

## 生成AI不要の理由

### 現状の要件で十分な理由

1. **データが構造化されている**
   - 日本酒の味覚データは数値化済み（甘辛度、淡濃度、f1-f6）
   - 類似度計算は数学的に定義可能

2. **推薦ロジックが明確**
   - コサイン類似度、ユークリッド距離などの確立された手法
   - 重み付き平均による好み学習

3. **リアルタイム性重視**
   - TypeScriptでの計算は高速（数ミリ秒）
   - API呼び出しのオーバーヘッドなし

4. **コスト効率**
   - 生成AI APIの利用料金不要
   - サーバーサイドの計算リソース不要

### 将来的に生成AIが有用になるケース

1. **自然言語での好み表現**
   - 「フルーティーで爽やかなもの」など曖昧な表現の解釈
   - レビューテキストからの感情分析

2. **複雑なコンテキスト理解**
   - 料理とのペアリング提案
   - TPOに応じた総合的な推薦

3. **説明文の生成**
   - レコメンド理由の自然な文章化
   - 味の表現の多様化

## 実装ロードマップ

### Phase 1: MVP（2週間）
- [ ] 基本的な好み分析（甘辛×淡濃）
- [ ] 類似度ベースレコメンド
- [ ] 好みマップUI

### Phase 2: 拡張（2週間）
- [ ] 6要素分析追加
- [ ] タイプ診断機能
- [ ] 気分別レコメンド

### Phase 3: 最適化（1週間）
- [ ] キャッシュ実装
- [ ] パフォーマンス改善
- [ ] A/Bテスト基盤

### Phase 4: 高度化（将来）
- [ ] 協調フィルタリング
- [ ] 時系列分析
- [ ] 生成AI統合（必要に応じて）